"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_klaxit_cookie-consent_src_index_js"],{

/***/ "./node_modules/@klaxit/cookie-consent/src/checkbox.js":
/*!*************************************************************!*\
  !*** ./node_modules/@klaxit/cookie-consent/src/checkbox.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Checkbox)
/* harmony export */ });
/*
 * This document includes material copied from or derived from
 * https://www.w3.org/TR/wai-aria-practices/examples/checkbox/checkbox-1/js/checkbox.js
 * Copyright © 2015 W3C® (MIT, ERCIM, Keio, Beihang).
 *
 */

class Checkbox {

  constructor(domNode) {
    this.domNode = domNode;

    this.keyCode = Object.freeze({
      "RETURN": 13,
      "SPACE": 32
    });
  }

  init() {
    this.domNode.tabIndex = 0;

    if (!this.domNode.getAttribute("aria-checked")) {
      this.domNode.setAttribute("aria-checked", "false");
    }

    this.domNode.addEventListener("keydown", this.handleKeydown.bind(this));
    this.domNode.addEventListener("click", this.handleClick.bind(this));
    this.domNode.addEventListener("focus", this.handleFocus.bind(this));
    this.domNode.addEventListener("blur", this.handleBlur.bind(this));

  }

  toggleCheckbox() {
    if (this.domNode.getAttribute("aria-disabled") === "true") {
      return;
    }

    if (this.domNode.getAttribute("aria-checked") === "true") {
      this.domNode.setAttribute("aria-checked", "false");
    }
    else {
      this.domNode.setAttribute("aria-checked", "true");
    }
  }

  /* EVENT HANDLERS */

  handleKeydown(event) {
    let flag = false;

    switch (event.keyCode) {
      case this.keyCode.SPACE:
        this.toggleCheckbox();
        flag = true;
        break;

      default:
        break;
    }

    if (flag) {
      event.stopPropagation();
      event.preventDefault();
    }
  }

  handleClick() {
    this.toggleCheckbox();
  }

  handleFocus() {
    this.domNode.classList.add("focus");
  }

  handleBlur() {
    this.domNode.classList.remove("focus");
  }
}


/***/ }),

/***/ "./node_modules/@klaxit/cookie-consent/src/consent_box.html.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@klaxit/cookie-consent/src/consent_box.html.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (`
<div class="cc-container cc-noselect">
  <div class="cc-box">
    <div class="cc-title">
      <!-- Title goes here -->
    </div>
    <div class="cc-section-landing">
      <div class="cc-description cc-content">
        <!-- Description goes here -->
      </div>
      <div class="cc-buttons">
        <div class="cc-btn cc-btn-settings cc-btn-show-settings">
          <!-- Cookie settings button -->
        </div>
        <div class="cc-btn cc-btn-reject">
          <!-- Reject button -->
        </div>
        <div class="cc-btn cc-btn-accept cc-btn-accept-all">
          <!-- Accept button -->
        </div>
      </div>
    </div>
    <div class="cc-section-settings cc-hidden">
      <div class="cc-content">
        <div class="cc-categories cc-checkboxes">
          <!-- Category checkboxes go here -->
        </div>
        <div class="cc-category-description">
          <!-- Category description go here -->
        </div>
      </div>
      <div class="cc-buttons">
        <div class="cc-btn cc-btn-settings cc-btn-hide-settings">
          <!-- Hide button -->
        </div>
        <div class="cc-btn cc-btn-reject">
          <!-- Reject button -->
        </div>
        <div class="cc-btn cc-btn-accept cc-btn-accept-selected">
          <!-- Accept Cookies button -->
        </div>
      </div>
    </div>
  </div>
</div>
`.trim());

/***/ }),

/***/ "./node_modules/@klaxit/cookie-consent/src/consent_box.js":
/*!****************************************************************!*\
  !*** ./node_modules/@klaxit/cookie-consent/src/consent_box.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ConsentBox)
/* harmony export */ });
/* harmony import */ var _consent_box_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./consent_box.html */ "./node_modules/@klaxit/cookie-consent/src/consent_box.html.js");
/* harmony import */ var _checkbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./checkbox */ "./node_modules/@klaxit/cookie-consent/src/checkbox.js");
/* harmony import */ var _observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./observable */ "./node_modules/@klaxit/cookie-consent/src/observable.js");


;



class ConsentBox extends _observable__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor( options = {} ){
    super()

    this.options = options
    this.categories = this.options.categories

    this._build()

    document.body.appendChild(this.container)
  }

  open(){
    this.container.classList.add("displayed");
  }

  close(){
    this.container.classList.remove("displayed");
  }

  selectedCategories(){
    const categoriesElem = this._firstByClass("cc-categories")
    const selectedCategories = []

    for (let catKey in this.categories) {
      const catElem = categoriesElem.querySelector(
        "[data-category='" + catKey + "']"
      )
      if(catElem.getAttribute("aria-checked") == "true") {
        selectedCategories.push(catKey)
      }
    }

    return selectedCategories
  }

  _build(){
    // Build container & content
    const elemBuilder = document.createElement("div")
    elemBuilder.innerHTML = _consent_box_html__WEBPACK_IMPORTED_MODULE_0__["default"]
    this.container = elemBuilder.firstChild

    this._firstByClass("cc-title").innerHTML = this.options.title;
    this._firstByClass("cc-description").innerHTML = this.options.description;
    this._firstByClass("cc-btn-accept-all").innerHTML = this.options.buttons.acceptAll;
    this._firstByClass("cc-btn-accept-selected").innerHTML = this.options.buttons.acceptSelected;
    this._firstByClass("cc-btn-show-settings").innerHTML = this.options.buttons.showSettings;
    this._firstByClass("cc-btn-hide-settings").innerHTML = this.options.buttons.hideSettings;

    const rejectBtns = this._allByClass("cc-btn-reject")
    for(let i=0; i < rejectBtns.length; i++){
      rejectBtns[i].innerHTML = this.options.buttons.reject;
    }

    this._buildCategories()
    this._setupButtons()
  }

  _buildCategories(){
    const categoriesElem = this._firstByClass("cc-categories")

    for (let catKey in this.categories) {
      const category = this.categories[catKey]

      const categoryElem = document.createElement("div")
      categoryElem.setAttribute("data-category", catKey)
      categoryElem.setAttribute("role", "checkbox")
      categoryElem.setAttribute("tabindex", "0")

      const categoryLbl = document.createElement("span")
      categoryLbl.setAttribute("data-category", catKey)
      categoryLbl.setAttribute("role", "link")
      categoryLbl.setAttribute("tabindex", "0")
      const lblNode = document.createTextNode(category.label)
      categoryLbl.appendChild(lblNode)

      categoryElem.appendChild(categoryLbl)

      categoriesElem.appendChild(categoryElem)

      categoryElem.addEventListener("click", this._categoryClicked.bind(this))

      if (category.checked) {
        categoryElem.setAttribute("aria-checked", "true")
        this._categoryClicked({target: categoryElem})
      }
      if (category.mandatory) {
        categoryElem.setAttribute("aria-disabled", "true")
      }
    }

    this._initCheckBoxes();
  }

  _initCheckBoxes() {
    const checkboxes = this.container.querySelectorAll("[role='checkbox']");
    for (let i = 0; i < checkboxes.length; i++) {
      new _checkbox__WEBPACK_IMPORTED_MODULE_1__["default"](checkboxes[i]).init();
    }
  }

  _categoryClicked(event) {
    const targetElement = event.target || event.srcElement;
    const targetCatKey = targetElement.dataset.category

    const descElem = this._firstByClass("cc-category-description")
    descElem.innerHTML = this.categories[targetCatKey].description
  }

  _setupButtons() {
    // Settings buttons
    this.container.querySelectorAll(".cc-btn-settings")
                  .forEach((elem) => {
      elem.addEventListener("click", this._toggleSettings.bind(this))
    })

    // Accept buttons
    this.container.querySelectorAll(".cc-btn-accept-all")
        .forEach((elem) => {
      elem.addEventListener("click", () => this.emit("accept-all"))
    })
    this.container.querySelectorAll(".cc-btn-accept-selected")
                  .forEach((elem) => {
      elem.addEventListener("click", () => this.emit("accept-selected"))
    })

    // Reject buttons
    this.container.querySelectorAll(".cc-btn-reject")
                  .forEach((elem) => {
      elem.addEventListener("click", () => this.emit("reject"))
    })
  }

  _toggleSettings() {
    const landingClassList = this._firstByClass("cc-section-landing").classList;
    const settingsClassList = this._firstByClass("cc-section-settings").classList;

    if(landingClassList.contains("cc-hidden")) {
      landingClassList.remove("cc-hidden")
      settingsClassList.add("cc-hidden")
    } else {
      landingClassList.add("cc-hidden")
      settingsClassList.remove("cc-hidden")
    }
  }


  _firstByClass(className){
    return this._allByClass(className)[0]
  }

  _allByClass(className){
    const elems = this.container.getElementsByClassName(className)
    if (elems.length > 0) { return elems }

    throw "Cannot find elements for class " + className + ".";
  }
}

/***/ }),

/***/ "./node_modules/@klaxit/cookie-consent/src/cookie.js":
/*!***********************************************************!*\
  !*** ./node_modules/@klaxit/cookie-consent/src/cookie.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Cookie)
/* harmony export */ });


const DEFAULT_STATUS = null
const DEFAULT_ACCEPTED_CATEGORIES = []
class Cookie {
  constructor(cookieOptions) {
    this.cookieOptions = cookieOptions
    this.load()
  }

  dump() {
    const serialized = JSON.stringify({
      status: this.status,
      acceptedCategories: this.acceptedCategories
    })

    let cookieStr = this.cookieOptions.name + "=" + serialized

    const expDate = new Date()
    const expDays = this.cookieOptions.expiryDays
    const expHours = (typeof expDays !== "number"  ? 365 : expDays ) * 24
    expDate.setHours(expDate.getHours() + expHours)
    cookieStr += "; expires=" + expDate.toUTCString()

    cookieStr += "; path=/"
    cookieStr += (this.cookieOptions.domain ? "; domain=" + this.cookieOptions.domain : "")
    cookieStr += (this.cookieOptions.secure ? "; secure" : "")
    cookieStr += (this.cookieOptions.sameSite ? "; SameSite=" +  this.cookieOptions.sameSite : "")

    document.cookie = cookieStr
  }

  load() {
    const existingConsent = this._getCookie(this.cookieOptions.name)
    if(existingConsent){
      const parsed = JSON.parse(existingConsent)
      this.status = parsed.status
      this.acceptedCategories = parsed.acceptedCategories
    } else {
      this.status = DEFAULT_STATUS
      this.acceptedCategories = DEFAULT_ACCEPTED_CATEGORIES
    }
  }

  _getCookie(cookieName) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${cookieName}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
  }
}

// Make default values public.
Object.defineProperties(Cookie, {
  DEFAULT_STATUS: { value: DEFAULT_STATUS, writable: false },
  DEFAULT_ACCEPTED_CATEGORIES: { value: DEFAULT_ACCEPTED_CATEGORIES, writable: false }
})


/***/ }),

/***/ "./node_modules/@klaxit/cookie-consent/src/cookie_consent.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@klaxit/cookie-consent/src/cookie_consent.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CookieConsent)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _default_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default_options */ "./node_modules/@klaxit/cookie-consent/src/default_options.js");
/* harmony import */ var _consent_box__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./consent_box */ "./node_modules/@klaxit/cookie-consent/src/consent_box.js");
/* harmony import */ var _cookie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cookie */ "./node_modules/@klaxit/cookie-consent/src/cookie.js");
/* harmony import */ var _observable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./observable */ "./node_modules/@klaxit/cookie-consent/src/observable.js");


;






// There is only one event source which is shared between
// instance and class. Emit is only accesible at the instance
// level however.
const SharedEmitter = new (events__WEBPACK_IMPORTED_MODULE_0___default())()

class CookieConsent extends _observable__WEBPACK_IMPORTED_MODULE_4__["default"] {
  constructor( options = {} ){
    // Since there must only be one instance (one consent box),
    // we will indicate user that it is not OK to create many
    // instances. Because of the option Object that may vary,
    // we cannot just return original instance, users would be
    // confused.
    if (CookieConsent._instance) {
      console.warn("CookieConsent already created, returning the original instance.")
      return CookieConsent._instance
    }
    super(CookieConsent._emitter)
    CookieConsent._instance = this


    this.options = Object.assign(_default_options__WEBPACK_IMPORTED_MODULE_1__["default"], options)
    this._consentBox = new _consent_box__WEBPACK_IMPORTED_MODULE_2__["default"](this.options)
    this._cookie = new _cookie__WEBPACK_IMPORTED_MODULE_3__["default"](this.options.cookie)

    this._consentBox.on("accept-all", () => {
      this._consentBox.close()
      this._cookie.status = "accepted"
      this._cookie.acceptedCategories = Object.keys(this.options.categories)
      this._cookie.dump()
      this.emit("accept")
      this.emit("change")
    })

    this._consentBox.on("accept-selected", () => {
      this._consentBox.close()
      this._cookie.status = "accepted"
      this._cookie.acceptedCategories = this._consentBox.selectedCategories()
      this._cookie.dump()
      this.emit("accept")
      this.emit("change")
    })

    this._consentBox.on("reject", () => {
      this._consentBox.close()
      this._cookie.status = "rejected"
      this._cookie.acceptedCategories = []
      this._cookie.dump()
      this.emit("reject")
      this.emit("change")
    })

    if (!this._cookie.status) {
      this._consentBox.open()
    }
  }

  open () {
    this._consentBox.open()
  }

  emit (event) {
    super.emit(event, this)
  }

  get status () {
    return this._cookie.status
  }

  get acceptedCategories () {
    return this._cookie.acceptedCategories
  }
}

// Static level properties, since class level static properties are still a
// proposal, we use Object.defineProperties.
Object.defineProperties(CookieConsent, {
  open: {
    value() {
      if (!this._instance) throw new Error("You must initialize a CookieConsent instance before opening.")

      this._instance.open()
    }
  },
  status: {
    get() { return this._instance ? this._instance.status : _cookie__WEBPACK_IMPORTED_MODULE_3__["default"].DEFAULT_STATUS }
  },
  acceptedCategories: {
    get() { return this._instance ? this._instance.acceptedCategories : _cookie__WEBPACK_IMPORTED_MODULE_3__["default"].DEFAULT_ACCEPTED_CATEGORIES }
  },
  on: {
    value: SharedEmitter.on.bind(SharedEmitter)
  }
})


/***/ }),

/***/ "./node_modules/@klaxit/cookie-consent/src/default_options.js":
/*!********************************************************************!*\
  !*** ./node_modules/@klaxit/cookie-consent/src/default_options.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  // Title of the
  title: "We use cookies",

  description: `Click “Accept” to enable us to use cookies to personalize
                this site. Customize your preferences in your
                Cookie Settings or click “Reject” if you do not want us
                to use cookies for this purpose. Learn more in our
                <a href="/cookies">Cookie Notice</a>.`,

  buttons: {
    acceptAll: "Accept",
    acceptSelected: "Accept Cookies",
    reject: "Reject",
    showSettings: "Cookies settings",
    hideSettings: "Hide",
  },

  categories: {
    essentials: {
			label: "Essential",
      description: `Essential cookies are necessary for features which
                    are essential to your use of our site or services,
                    such as account login, authentication, and site security.`,
      checked: true,
      mandatory: true
		},
		analytics: {
			label: "Analytics",
      description: `Analytics cookies allow us to analyze your visits and
                    actions on our websites, and offer you a more relevant
                    experience.`
		}
  },

  cookie: {
    // Name of the cookie storing the consent state
    name: "cookie_consent",

    // If null, will take `location.hostname` by default
    domain: null,

    // Duration of the consent
    expiryDays: 365,

    // If true, the cookies will only be allowed over https
    secure: false,

    // See https://developer.mozilla.org/fr/docs/Web/HTTP/Headers/Set-Cookie/SameSite
    sameSite: "Lax",
  }
});

/***/ }),

/***/ "./node_modules/@klaxit/cookie-consent/src/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@klaxit/cookie-consent/src/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _styles_main_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/main.scss */ "./node_modules/@klaxit/cookie-consent/src/styles/main.scss");
/* harmony import */ var _cookie_consent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cookie_consent */ "./node_modules/@klaxit/cookie-consent/src/cookie_consent.js");


;



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_cookie_consent__WEBPACK_IMPORTED_MODULE_1__["default"]);

window.CookieConsent = _cookie_consent__WEBPACK_IMPORTED_MODULE_1__["default"]


/***/ }),

/***/ "./node_modules/@klaxit/cookie-consent/src/observable.js":
/*!***************************************************************!*\
  !*** ./node_modules/@klaxit/cookie-consent/src/observable.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Observable)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);


;

class Observable {
  constructor(emitter = null) {
    this._emitter = emitter || new (events__WEBPACK_IMPORTED_MODULE_0___default())()
  }

  on() { this._emitter.on.apply(this._emitter, arguments)}
  emit() { this._emitter.emit.apply(this._emitter, arguments)}
}


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/@klaxit/cookie-consent/src/styles/main.scss":
/*!******************************************************************!*\
  !*** ./node_modules/@klaxit/cookie-consent/src/styles/main.scss ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfa2xheGl0X2Nvb2tpZS1jb25zZW50X3NyY19pbmRleF9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM3RUEsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NZOztBQUVaLENBQStDO0FBQ2Q7QUFDSTs7QUFFdEIseUJBQXlCLG1EQUFVO0FBQ2xELDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hmQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2xheGl0L2Nvb2tpZS1jb25zZW50L3NyYy9jaGVja2JveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtsYXhpdC9jb29raWUtY29uc2VudC9zcmMvY29uc2VudF9ib3guaHRtbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtsYXhpdC9jb29raWUtY29uc2VudC9zcmMvY29uc2VudF9ib3guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BrbGF4aXQvY29va2llLWNvbnNlbnQvc3JjL2Nvb2tpZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtsYXhpdC9jb29raWUtY29uc2VudC9zcmMvY29va2llX2NvbnNlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BrbGF4aXQvY29va2llLWNvbnNlbnQvc3JjL2RlZmF1bHRfb3B0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtsYXhpdC9jb29raWUtY29uc2VudC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BrbGF4aXQvY29va2llLWNvbnNlbnQvc3JjL29ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BrbGF4aXQvY29va2llLWNvbnNlbnQvc3JjL3N0eWxlcy9tYWluLnNjc3M/OTQ2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogVGhpcyBkb2N1bWVudCBpbmNsdWRlcyBtYXRlcmlhbCBjb3BpZWQgZnJvbSBvciBkZXJpdmVkIGZyb21cbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMvZXhhbXBsZXMvY2hlY2tib3gvY2hlY2tib3gtMS9qcy9jaGVja2JveC5qc1xuICogQ29weXJpZ2h0IMKpIDIwMTUgVzNDwq4gKE1JVCwgRVJDSU0sIEtlaW8sIEJlaWhhbmcpLlxuICpcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja2JveCB7XG5cbiAgY29uc3RydWN0b3IoZG9tTm9kZSkge1xuICAgIHRoaXMuZG9tTm9kZSA9IGRvbU5vZGU7XG5cbiAgICB0aGlzLmtleUNvZGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIFwiUkVUVVJOXCI6IDEzLFxuICAgICAgXCJTUEFDRVwiOiAzMlxuICAgIH0pO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmRvbU5vZGUudGFiSW5kZXggPSAwO1xuXG4gICAgaWYgKCF0aGlzLmRvbU5vZGUuZ2V0QXR0cmlidXRlKFwiYXJpYS1jaGVja2VkXCIpKSB7XG4gICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1jaGVja2VkXCIsIFwiZmFsc2VcIik7XG4gICAgfVxuXG4gICAgdGhpcy5kb21Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmRvbU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgdGhpcy5kb21Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLmhhbmRsZUZvY3VzLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZG9tTm9kZS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmhhbmRsZUJsdXIuYmluZCh0aGlzKSk7XG5cbiAgfVxuXG4gIHRvZ2dsZUNoZWNrYm94KCkge1xuICAgIGlmICh0aGlzLmRvbU5vZGUuZ2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kb21Ob2RlLmdldEF0dHJpYnV0ZShcImFyaWEtY2hlY2tlZFwiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgIHRoaXMuZG9tTm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNoZWNrZWRcIiwgXCJmYWxzZVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmRvbU5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1jaGVja2VkXCIsIFwidHJ1ZVwiKTtcbiAgICB9XG4gIH1cblxuICAvKiBFVkVOVCBIQU5ETEVSUyAqL1xuXG4gIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICBsZXQgZmxhZyA9IGZhbHNlO1xuXG4gICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIHRoaXMua2V5Q29kZS5TUEFDRTpcbiAgICAgICAgdGhpcy50b2dnbGVDaGVja2JveCgpO1xuICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChmbGFnKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgdGhpcy50b2dnbGVDaGVja2JveCgpO1xuICB9XG5cbiAgaGFuZGxlRm9jdXMoKSB7XG4gICAgdGhpcy5kb21Ob2RlLmNsYXNzTGlzdC5hZGQoXCJmb2N1c1wiKTtcbiAgfVxuXG4gIGhhbmRsZUJsdXIoKSB7XG4gICAgdGhpcy5kb21Ob2RlLmNsYXNzTGlzdC5yZW1vdmUoXCJmb2N1c1wiKTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgYFxuPGRpdiBjbGFzcz1cImNjLWNvbnRhaW5lciBjYy1ub3NlbGVjdFwiPlxuICA8ZGl2IGNsYXNzPVwiY2MtYm94XCI+XG4gICAgPGRpdiBjbGFzcz1cImNjLXRpdGxlXCI+XG4gICAgICA8IS0tIFRpdGxlIGdvZXMgaGVyZSAtLT5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY2Mtc2VjdGlvbi1sYW5kaW5nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2MtZGVzY3JpcHRpb24gY2MtY29udGVudFwiPlxuICAgICAgICA8IS0tIERlc2NyaXB0aW9uIGdvZXMgaGVyZSAtLT5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImNjLWJ1dHRvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNjLWJ0biBjYy1idG4tc2V0dGluZ3MgY2MtYnRuLXNob3ctc2V0dGluZ3NcIj5cbiAgICAgICAgICA8IS0tIENvb2tpZSBzZXR0aW5ncyBidXR0b24gLS0+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2MtYnRuIGNjLWJ0bi1yZWplY3RcIj5cbiAgICAgICAgICA8IS0tIFJlamVjdCBidXR0b24gLS0+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2MtYnRuIGNjLWJ0bi1hY2NlcHQgY2MtYnRuLWFjY2VwdC1hbGxcIj5cbiAgICAgICAgICA8IS0tIEFjY2VwdCBidXR0b24gLS0+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNjLXNlY3Rpb24tc2V0dGluZ3MgY2MtaGlkZGVuXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2MtY29udGVudFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2MtY2F0ZWdvcmllcyBjYy1jaGVja2JveGVzXCI+XG4gICAgICAgICAgPCEtLSBDYXRlZ29yeSBjaGVja2JveGVzIGdvIGhlcmUgLS0+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2MtY2F0ZWdvcnktZGVzY3JpcHRpb25cIj5cbiAgICAgICAgICA8IS0tIENhdGVnb3J5IGRlc2NyaXB0aW9uIGdvIGhlcmUgLS0+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2MtYnV0dG9uc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2MtYnRuIGNjLWJ0bi1zZXR0aW5ncyBjYy1idG4taGlkZS1zZXR0aW5nc1wiPlxuICAgICAgICAgIDwhLS0gSGlkZSBidXR0b24gLS0+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2MtYnRuIGNjLWJ0bi1yZWplY3RcIj5cbiAgICAgICAgICA8IS0tIFJlamVjdCBidXR0b24gLS0+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2MtYnRuIGNjLWJ0bi1hY2NlcHQgY2MtYnRuLWFjY2VwdC1zZWxlY3RlZFwiPlxuICAgICAgICAgIDwhLS0gQWNjZXB0IENvb2tpZXMgYnV0dG9uIC0tPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuYC50cmltKCkiLCJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgY29uc2VudEJveEh0bWwgZnJvbSBcIi4vY29uc2VudF9ib3guaHRtbFwiXG5pbXBvcnQgQ2hlY2tib3ggZnJvbSBcIi4vY2hlY2tib3hcIlxuaW1wb3J0IE9ic2VydmFibGUgZnJvbSBcIi4vb2JzZXJ2YWJsZVwiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnNlbnRCb3ggZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgY29uc3RydWN0b3IoIG9wdGlvbnMgPSB7fSApe1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnNcbiAgICB0aGlzLmNhdGVnb3JpZXMgPSB0aGlzLm9wdGlvbnMuY2F0ZWdvcmllc1xuXG4gICAgdGhpcy5fYnVpbGQoKVxuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcilcbiAgfVxuXG4gIG9wZW4oKXtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZGlzcGxheWVkXCIpO1xuICB9XG5cbiAgY2xvc2UoKXtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKFwiZGlzcGxheWVkXCIpO1xuICB9XG5cbiAgc2VsZWN0ZWRDYXRlZ29yaWVzKCl7XG4gICAgY29uc3QgY2F0ZWdvcmllc0VsZW0gPSB0aGlzLl9maXJzdEJ5Q2xhc3MoXCJjYy1jYXRlZ29yaWVzXCIpXG4gICAgY29uc3Qgc2VsZWN0ZWRDYXRlZ29yaWVzID0gW11cblxuICAgIGZvciAobGV0IGNhdEtleSBpbiB0aGlzLmNhdGVnb3JpZXMpIHtcbiAgICAgIGNvbnN0IGNhdEVsZW0gPSBjYXRlZ29yaWVzRWxlbS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBcIltkYXRhLWNhdGVnb3J5PSdcIiArIGNhdEtleSArIFwiJ11cIlxuICAgICAgKVxuICAgICAgaWYoY2F0RWxlbS5nZXRBdHRyaWJ1dGUoXCJhcmlhLWNoZWNrZWRcIikgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgc2VsZWN0ZWRDYXRlZ29yaWVzLnB1c2goY2F0S2V5KVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3RlZENhdGVnb3JpZXNcbiAgfVxuXG4gIF9idWlsZCgpe1xuICAgIC8vIEJ1aWxkIGNvbnRhaW5lciAmIGNvbnRlbnRcbiAgICBjb25zdCBlbGVtQnVpbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICBlbGVtQnVpbGRlci5pbm5lckhUTUwgPSBjb25zZW50Qm94SHRtbFxuICAgIHRoaXMuY29udGFpbmVyID0gZWxlbUJ1aWxkZXIuZmlyc3RDaGlsZFxuXG4gICAgdGhpcy5fZmlyc3RCeUNsYXNzKFwiY2MtdGl0bGVcIikuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIHRoaXMuX2ZpcnN0QnlDbGFzcyhcImNjLWRlc2NyaXB0aW9uXCIpLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5kZXNjcmlwdGlvbjtcbiAgICB0aGlzLl9maXJzdEJ5Q2xhc3MoXCJjYy1idG4tYWNjZXB0LWFsbFwiKS5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuYnV0dG9ucy5hY2NlcHRBbGw7XG4gICAgdGhpcy5fZmlyc3RCeUNsYXNzKFwiY2MtYnRuLWFjY2VwdC1zZWxlY3RlZFwiKS5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuYnV0dG9ucy5hY2NlcHRTZWxlY3RlZDtcbiAgICB0aGlzLl9maXJzdEJ5Q2xhc3MoXCJjYy1idG4tc2hvdy1zZXR0aW5nc1wiKS5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuYnV0dG9ucy5zaG93U2V0dGluZ3M7XG4gICAgdGhpcy5fZmlyc3RCeUNsYXNzKFwiY2MtYnRuLWhpZGUtc2V0dGluZ3NcIikuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLmJ1dHRvbnMuaGlkZVNldHRpbmdzO1xuXG4gICAgY29uc3QgcmVqZWN0QnRucyA9IHRoaXMuX2FsbEJ5Q2xhc3MoXCJjYy1idG4tcmVqZWN0XCIpXG4gICAgZm9yKGxldCBpPTA7IGkgPCByZWplY3RCdG5zLmxlbmd0aDsgaSsrKXtcbiAgICAgIHJlamVjdEJ0bnNbaV0uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLmJ1dHRvbnMucmVqZWN0O1xuICAgIH1cblxuICAgIHRoaXMuX2J1aWxkQ2F0ZWdvcmllcygpXG4gICAgdGhpcy5fc2V0dXBCdXR0b25zKClcbiAgfVxuXG4gIF9idWlsZENhdGVnb3JpZXMoKXtcbiAgICBjb25zdCBjYXRlZ29yaWVzRWxlbSA9IHRoaXMuX2ZpcnN0QnlDbGFzcyhcImNjLWNhdGVnb3JpZXNcIilcblxuICAgIGZvciAobGV0IGNhdEtleSBpbiB0aGlzLmNhdGVnb3JpZXMpIHtcbiAgICAgIGNvbnN0IGNhdGVnb3J5ID0gdGhpcy5jYXRlZ29yaWVzW2NhdEtleV1cblxuICAgICAgY29uc3QgY2F0ZWdvcnlFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgY2F0ZWdvcnlFbGVtLnNldEF0dHJpYnV0ZShcImRhdGEtY2F0ZWdvcnlcIiwgY2F0S2V5KVxuICAgICAgY2F0ZWdvcnlFbGVtLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjaGVja2JveFwiKVxuICAgICAgY2F0ZWdvcnlFbGVtLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKVxuXG4gICAgICBjb25zdCBjYXRlZ29yeUxibCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgICBjYXRlZ29yeUxibC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNhdGVnb3J5XCIsIGNhdEtleSlcbiAgICAgIGNhdGVnb3J5TGJsLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJsaW5rXCIpXG4gICAgICBjYXRlZ29yeUxibC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIjBcIilcbiAgICAgIGNvbnN0IGxibE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjYXRlZ29yeS5sYWJlbClcbiAgICAgIGNhdGVnb3J5TGJsLmFwcGVuZENoaWxkKGxibE5vZGUpXG5cbiAgICAgIGNhdGVnb3J5RWxlbS5hcHBlbmRDaGlsZChjYXRlZ29yeUxibClcblxuICAgICAgY2F0ZWdvcmllc0VsZW0uYXBwZW5kQ2hpbGQoY2F0ZWdvcnlFbGVtKVxuXG4gICAgICBjYXRlZ29yeUVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2NhdGVnb3J5Q2xpY2tlZC5iaW5kKHRoaXMpKVxuXG4gICAgICBpZiAoY2F0ZWdvcnkuY2hlY2tlZCkge1xuICAgICAgICBjYXRlZ29yeUVsZW0uc2V0QXR0cmlidXRlKFwiYXJpYS1jaGVja2VkXCIsIFwidHJ1ZVwiKVxuICAgICAgICB0aGlzLl9jYXRlZ29yeUNsaWNrZWQoe3RhcmdldDogY2F0ZWdvcnlFbGVtfSlcbiAgICAgIH1cbiAgICAgIGlmIChjYXRlZ29yeS5tYW5kYXRvcnkpIHtcbiAgICAgICAgY2F0ZWdvcnlFbGVtLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgXCJ0cnVlXCIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdENoZWNrQm94ZXMoKTtcbiAgfVxuXG4gIF9pbml0Q2hlY2tCb3hlcygpIHtcbiAgICBjb25zdCBjaGVja2JveGVzID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltyb2xlPSdjaGVja2JveCddXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hlY2tib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmV3IENoZWNrYm94KGNoZWNrYm94ZXNbaV0pLmluaXQoKTtcbiAgICB9XG4gIH1cblxuICBfY2F0ZWdvcnlDbGlja2VkKGV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuICAgIGNvbnN0IHRhcmdldENhdEtleSA9IHRhcmdldEVsZW1lbnQuZGF0YXNldC5jYXRlZ29yeVxuXG4gICAgY29uc3QgZGVzY0VsZW0gPSB0aGlzLl9maXJzdEJ5Q2xhc3MoXCJjYy1jYXRlZ29yeS1kZXNjcmlwdGlvblwiKVxuICAgIGRlc2NFbGVtLmlubmVySFRNTCA9IHRoaXMuY2F0ZWdvcmllc1t0YXJnZXRDYXRLZXldLmRlc2NyaXB0aW9uXG4gIH1cblxuICBfc2V0dXBCdXR0b25zKCkge1xuICAgIC8vIFNldHRpbmdzIGJ1dHRvbnNcbiAgICB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLmNjLWJ0bi1zZXR0aW5nc1wiKVxuICAgICAgICAgICAgICAgICAgLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX3RvZ2dsZVNldHRpbmdzLmJpbmQodGhpcykpXG4gICAgfSlcblxuICAgIC8vIEFjY2VwdCBidXR0b25zXG4gICAgdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5jYy1idG4tYWNjZXB0LWFsbFwiKVxuICAgICAgICAuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5lbWl0KFwiYWNjZXB0LWFsbFwiKSlcbiAgICB9KVxuICAgIHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuY2MtYnRuLWFjY2VwdC1zZWxlY3RlZFwiKVxuICAgICAgICAgICAgICAgICAgLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuZW1pdChcImFjY2VwdC1zZWxlY3RlZFwiKSlcbiAgICB9KVxuXG4gICAgLy8gUmVqZWN0IGJ1dHRvbnNcbiAgICB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFwiLmNjLWJ0bi1yZWplY3RcIilcbiAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLmVtaXQoXCJyZWplY3RcIikpXG4gICAgfSlcbiAgfVxuXG4gIF90b2dnbGVTZXR0aW5ncygpIHtcbiAgICBjb25zdCBsYW5kaW5nQ2xhc3NMaXN0ID0gdGhpcy5fZmlyc3RCeUNsYXNzKFwiY2Mtc2VjdGlvbi1sYW5kaW5nXCIpLmNsYXNzTGlzdDtcbiAgICBjb25zdCBzZXR0aW5nc0NsYXNzTGlzdCA9IHRoaXMuX2ZpcnN0QnlDbGFzcyhcImNjLXNlY3Rpb24tc2V0dGluZ3NcIikuY2xhc3NMaXN0O1xuXG4gICAgaWYobGFuZGluZ0NsYXNzTGlzdC5jb250YWlucyhcImNjLWhpZGRlblwiKSkge1xuICAgICAgbGFuZGluZ0NsYXNzTGlzdC5yZW1vdmUoXCJjYy1oaWRkZW5cIilcbiAgICAgIHNldHRpbmdzQ2xhc3NMaXN0LmFkZChcImNjLWhpZGRlblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBsYW5kaW5nQ2xhc3NMaXN0LmFkZChcImNjLWhpZGRlblwiKVxuICAgICAgc2V0dGluZ3NDbGFzc0xpc3QucmVtb3ZlKFwiY2MtaGlkZGVuXCIpXG4gICAgfVxuICB9XG5cblxuICBfZmlyc3RCeUNsYXNzKGNsYXNzTmFtZSl7XG4gICAgcmV0dXJuIHRoaXMuX2FsbEJ5Q2xhc3MoY2xhc3NOYW1lKVswXVxuICB9XG5cbiAgX2FsbEJ5Q2xhc3MoY2xhc3NOYW1lKXtcbiAgICBjb25zdCBlbGVtcyA9IHRoaXMuY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NOYW1lKVxuICAgIGlmIChlbGVtcy5sZW5ndGggPiAwKSB7IHJldHVybiBlbGVtcyB9XG5cbiAgICB0aHJvdyBcIkNhbm5vdCBmaW5kIGVsZW1lbnRzIGZvciBjbGFzcyBcIiArIGNsYXNzTmFtZSArIFwiLlwiO1xuICB9XG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxuY29uc3QgREVGQVVMVF9TVEFUVVMgPSBudWxsXG5jb25zdCBERUZBVUxUX0FDQ0VQVEVEX0NBVEVHT1JJRVMgPSBbXVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29va2llIHtcbiAgY29uc3RydWN0b3IoY29va2llT3B0aW9ucykge1xuICAgIHRoaXMuY29va2llT3B0aW9ucyA9IGNvb2tpZU9wdGlvbnNcbiAgICB0aGlzLmxvYWQoKVxuICB9XG5cbiAgZHVtcCgpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgIGFjY2VwdGVkQ2F0ZWdvcmllczogdGhpcy5hY2NlcHRlZENhdGVnb3JpZXNcbiAgICB9KVxuXG4gICAgbGV0IGNvb2tpZVN0ciA9IHRoaXMuY29va2llT3B0aW9ucy5uYW1lICsgXCI9XCIgKyBzZXJpYWxpemVkXG5cbiAgICBjb25zdCBleHBEYXRlID0gbmV3IERhdGUoKVxuICAgIGNvbnN0IGV4cERheXMgPSB0aGlzLmNvb2tpZU9wdGlvbnMuZXhwaXJ5RGF5c1xuICAgIGNvbnN0IGV4cEhvdXJzID0gKHR5cGVvZiBleHBEYXlzICE9PSBcIm51bWJlclwiICA/IDM2NSA6IGV4cERheXMgKSAqIDI0XG4gICAgZXhwRGF0ZS5zZXRIb3VycyhleHBEYXRlLmdldEhvdXJzKCkgKyBleHBIb3VycylcbiAgICBjb29raWVTdHIgKz0gXCI7IGV4cGlyZXM9XCIgKyBleHBEYXRlLnRvVVRDU3RyaW5nKClcblxuICAgIGNvb2tpZVN0ciArPSBcIjsgcGF0aD0vXCJcbiAgICBjb29raWVTdHIgKz0gKHRoaXMuY29va2llT3B0aW9ucy5kb21haW4gPyBcIjsgZG9tYWluPVwiICsgdGhpcy5jb29raWVPcHRpb25zLmRvbWFpbiA6IFwiXCIpXG4gICAgY29va2llU3RyICs9ICh0aGlzLmNvb2tpZU9wdGlvbnMuc2VjdXJlID8gXCI7IHNlY3VyZVwiIDogXCJcIilcbiAgICBjb29raWVTdHIgKz0gKHRoaXMuY29va2llT3B0aW9ucy5zYW1lU2l0ZSA/IFwiOyBTYW1lU2l0ZT1cIiArICB0aGlzLmNvb2tpZU9wdGlvbnMuc2FtZVNpdGUgOiBcIlwiKVxuXG4gICAgZG9jdW1lbnQuY29va2llID0gY29va2llU3RyXG4gIH1cblxuICBsb2FkKCkge1xuICAgIGNvbnN0IGV4aXN0aW5nQ29uc2VudCA9IHRoaXMuX2dldENvb2tpZSh0aGlzLmNvb2tpZU9wdGlvbnMubmFtZSlcbiAgICBpZihleGlzdGluZ0NvbnNlbnQpe1xuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShleGlzdGluZ0NvbnNlbnQpXG4gICAgICB0aGlzLnN0YXR1cyA9IHBhcnNlZC5zdGF0dXNcbiAgICAgIHRoaXMuYWNjZXB0ZWRDYXRlZ29yaWVzID0gcGFyc2VkLmFjY2VwdGVkQ2F0ZWdvcmllc1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IERFRkFVTFRfU1RBVFVTXG4gICAgICB0aGlzLmFjY2VwdGVkQ2F0ZWdvcmllcyA9IERFRkFVTFRfQUNDRVBURURfQ0FURUdPUklFU1xuICAgIH1cbiAgfVxuXG4gIF9nZXRDb29raWUoY29va2llTmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gYDsgJHtkb2N1bWVudC5jb29raWV9YDtcbiAgICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNwbGl0KGA7ICR7Y29va2llTmFtZX09YCk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMikgcmV0dXJuIHBhcnRzLnBvcCgpLnNwbGl0KCc7Jykuc2hpZnQoKTtcbiAgfVxufVxuXG4vLyBNYWtlIGRlZmF1bHQgdmFsdWVzIHB1YmxpYy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvb2tpZSwge1xuICBERUZBVUxUX1NUQVRVUzogeyB2YWx1ZTogREVGQVVMVF9TVEFUVVMsIHdyaXRhYmxlOiBmYWxzZSB9LFxuICBERUZBVUxUX0FDQ0VQVEVEX0NBVEVHT1JJRVM6IHsgdmFsdWU6IERFRkFVTFRfQUNDRVBURURfQ0FURUdPUklFUywgd3JpdGFibGU6IGZhbHNlIH1cbn0pXG4iLCJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJldmVudHNcIlxuXG5pbXBvcnQgZGVmYXVsdE9wdGlvbnMgZnJvbSBcIi4vZGVmYXVsdF9vcHRpb25zXCJcbmltcG9ydCBDb25zZW50Qm94IGZyb20gXCIuL2NvbnNlbnRfYm94XCJcbmltcG9ydCBDb29raWUgZnJvbSBcIi4vY29va2llXCJcbmltcG9ydCBPYnNlcnZhYmxlIGZyb20gXCIuL29ic2VydmFibGVcIlxuXG4vLyBUaGVyZSBpcyBvbmx5IG9uZSBldmVudCBzb3VyY2Ugd2hpY2ggaXMgc2hhcmVkIGJldHdlZW5cbi8vIGluc3RhbmNlIGFuZCBjbGFzcy4gRW1pdCBpcyBvbmx5IGFjY2VzaWJsZSBhdCB0aGUgaW5zdGFuY2Vcbi8vIGxldmVsIGhvd2V2ZXIuXG5jb25zdCBTaGFyZWRFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvb2tpZUNvbnNlbnQgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgY29uc3RydWN0b3IoIG9wdGlvbnMgPSB7fSApe1xuICAgIC8vIFNpbmNlIHRoZXJlIG11c3Qgb25seSBiZSBvbmUgaW5zdGFuY2UgKG9uZSBjb25zZW50IGJveCksXG4gICAgLy8gd2Ugd2lsbCBpbmRpY2F0ZSB1c2VyIHRoYXQgaXQgaXMgbm90IE9LIHRvIGNyZWF0ZSBtYW55XG4gICAgLy8gaW5zdGFuY2VzLiBCZWNhdXNlIG9mIHRoZSBvcHRpb24gT2JqZWN0IHRoYXQgbWF5IHZhcnksXG4gICAgLy8gd2UgY2Fubm90IGp1c3QgcmV0dXJuIG9yaWdpbmFsIGluc3RhbmNlLCB1c2VycyB3b3VsZCBiZVxuICAgIC8vIGNvbmZ1c2VkLlxuICAgIGlmIChDb29raWVDb25zZW50Ll9pbnN0YW5jZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ29va2llQ29uc2VudCBhbHJlYWR5IGNyZWF0ZWQsIHJldHVybmluZyB0aGUgb3JpZ2luYWwgaW5zdGFuY2UuXCIpXG4gICAgICByZXR1cm4gQ29va2llQ29uc2VudC5faW5zdGFuY2VcbiAgICB9XG4gICAgc3VwZXIoQ29va2llQ29uc2VudC5fZW1pdHRlcilcbiAgICBDb29raWVDb25zZW50Ll9pbnN0YW5jZSA9IHRoaXNcblxuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0T3B0aW9ucywgb3B0aW9ucylcbiAgICB0aGlzLl9jb25zZW50Qm94ID0gbmV3IENvbnNlbnRCb3godGhpcy5vcHRpb25zKVxuICAgIHRoaXMuX2Nvb2tpZSA9IG5ldyBDb29raWUodGhpcy5vcHRpb25zLmNvb2tpZSlcblxuICAgIHRoaXMuX2NvbnNlbnRCb3gub24oXCJhY2NlcHQtYWxsXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbnNlbnRCb3guY2xvc2UoKVxuICAgICAgdGhpcy5fY29va2llLnN0YXR1cyA9IFwiYWNjZXB0ZWRcIlxuICAgICAgdGhpcy5fY29va2llLmFjY2VwdGVkQ2F0ZWdvcmllcyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5jYXRlZ29yaWVzKVxuICAgICAgdGhpcy5fY29va2llLmR1bXAoKVxuICAgICAgdGhpcy5lbWl0KFwiYWNjZXB0XCIpXG4gICAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIilcbiAgICB9KVxuXG4gICAgdGhpcy5fY29uc2VudEJveC5vbihcImFjY2VwdC1zZWxlY3RlZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25zZW50Qm94LmNsb3NlKClcbiAgICAgIHRoaXMuX2Nvb2tpZS5zdGF0dXMgPSBcImFjY2VwdGVkXCJcbiAgICAgIHRoaXMuX2Nvb2tpZS5hY2NlcHRlZENhdGVnb3JpZXMgPSB0aGlzLl9jb25zZW50Qm94LnNlbGVjdGVkQ2F0ZWdvcmllcygpXG4gICAgICB0aGlzLl9jb29raWUuZHVtcCgpXG4gICAgICB0aGlzLmVtaXQoXCJhY2NlcHRcIilcbiAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKVxuICAgIH0pXG5cbiAgICB0aGlzLl9jb25zZW50Qm94Lm9uKFwicmVqZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbnNlbnRCb3guY2xvc2UoKVxuICAgICAgdGhpcy5fY29va2llLnN0YXR1cyA9IFwicmVqZWN0ZWRcIlxuICAgICAgdGhpcy5fY29va2llLmFjY2VwdGVkQ2F0ZWdvcmllcyA9IFtdXG4gICAgICB0aGlzLl9jb29raWUuZHVtcCgpXG4gICAgICB0aGlzLmVtaXQoXCJyZWplY3RcIilcbiAgICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKVxuICAgIH0pXG5cbiAgICBpZiAoIXRoaXMuX2Nvb2tpZS5zdGF0dXMpIHtcbiAgICAgIHRoaXMuX2NvbnNlbnRCb3gub3BlbigpXG4gICAgfVxuICB9XG5cbiAgb3BlbiAoKSB7XG4gICAgdGhpcy5fY29uc2VudEJveC5vcGVuKClcbiAgfVxuXG4gIGVtaXQgKGV2ZW50KSB7XG4gICAgc3VwZXIuZW1pdChldmVudCwgdGhpcylcbiAgfVxuXG4gIGdldCBzdGF0dXMgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb29raWUuc3RhdHVzXG4gIH1cblxuICBnZXQgYWNjZXB0ZWRDYXRlZ29yaWVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29va2llLmFjY2VwdGVkQ2F0ZWdvcmllc1xuICB9XG59XG5cbi8vIFN0YXRpYyBsZXZlbCBwcm9wZXJ0aWVzLCBzaW5jZSBjbGFzcyBsZXZlbCBzdGF0aWMgcHJvcGVydGllcyBhcmUgc3RpbGwgYVxuLy8gcHJvcG9zYWwsIHdlIHVzZSBPYmplY3QuZGVmaW5lUHJvcGVydGllcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvb2tpZUNvbnNlbnQsIHtcbiAgb3Blbjoge1xuICAgIHZhbHVlKCkge1xuICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgaW5pdGlhbGl6ZSBhIENvb2tpZUNvbnNlbnQgaW5zdGFuY2UgYmVmb3JlIG9wZW5pbmcuXCIpXG5cbiAgICAgIHRoaXMuX2luc3RhbmNlLm9wZW4oKVxuICAgIH1cbiAgfSxcbiAgc3RhdHVzOiB7XG4gICAgZ2V0KCkgeyByZXR1cm4gdGhpcy5faW5zdGFuY2UgPyB0aGlzLl9pbnN0YW5jZS5zdGF0dXMgOiBDb29raWUuREVGQVVMVF9TVEFUVVMgfVxuICB9LFxuICBhY2NlcHRlZENhdGVnb3JpZXM6IHtcbiAgICBnZXQoKSB7IHJldHVybiB0aGlzLl9pbnN0YW5jZSA/IHRoaXMuX2luc3RhbmNlLmFjY2VwdGVkQ2F0ZWdvcmllcyA6IENvb2tpZS5ERUZBVUxUX0FDQ0VQVEVEX0NBVEVHT1JJRVMgfVxuICB9LFxuICBvbjoge1xuICAgIHZhbHVlOiBTaGFyZWRFbWl0dGVyLm9uLmJpbmQoU2hhcmVkRW1pdHRlcilcbiAgfVxufSlcbiIsIlwidXNlIHN0cmljdFwiXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8gVGl0bGUgb2YgdGhlXG4gIHRpdGxlOiBcIldlIHVzZSBjb29raWVzXCIsXG5cbiAgZGVzY3JpcHRpb246IGBDbGljayDigJxBY2NlcHTigJ0gdG8gZW5hYmxlIHVzIHRvIHVzZSBjb29raWVzIHRvIHBlcnNvbmFsaXplXG4gICAgICAgICAgICAgICAgdGhpcyBzaXRlLiBDdXN0b21pemUgeW91ciBwcmVmZXJlbmNlcyBpbiB5b3VyXG4gICAgICAgICAgICAgICAgQ29va2llIFNldHRpbmdzIG9yIGNsaWNrIOKAnFJlamVjdOKAnSBpZiB5b3UgZG8gbm90IHdhbnQgdXNcbiAgICAgICAgICAgICAgICB0byB1c2UgY29va2llcyBmb3IgdGhpcyBwdXJwb3NlLiBMZWFybiBtb3JlIGluIG91clxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIvY29va2llc1wiPkNvb2tpZSBOb3RpY2U8L2E+LmAsXG5cbiAgYnV0dG9uczoge1xuICAgIGFjY2VwdEFsbDogXCJBY2NlcHRcIixcbiAgICBhY2NlcHRTZWxlY3RlZDogXCJBY2NlcHQgQ29va2llc1wiLFxuICAgIHJlamVjdDogXCJSZWplY3RcIixcbiAgICBzaG93U2V0dGluZ3M6IFwiQ29va2llcyBzZXR0aW5nc1wiLFxuICAgIGhpZGVTZXR0aW5nczogXCJIaWRlXCIsXG4gIH0sXG5cbiAgY2F0ZWdvcmllczoge1xuICAgIGVzc2VudGlhbHM6IHtcblx0XHRcdGxhYmVsOiBcIkVzc2VudGlhbFwiLFxuICAgICAgZGVzY3JpcHRpb246IGBFc3NlbnRpYWwgY29va2llcyBhcmUgbmVjZXNzYXJ5IGZvciBmZWF0dXJlcyB3aGljaFxuICAgICAgICAgICAgICAgICAgICBhcmUgZXNzZW50aWFsIHRvIHlvdXIgdXNlIG9mIG91ciBzaXRlIG9yIHNlcnZpY2VzLFxuICAgICAgICAgICAgICAgICAgICBzdWNoIGFzIGFjY291bnQgbG9naW4sIGF1dGhlbnRpY2F0aW9uLCBhbmQgc2l0ZSBzZWN1cml0eS5gLFxuICAgICAgY2hlY2tlZDogdHJ1ZSxcbiAgICAgIG1hbmRhdG9yeTogdHJ1ZVxuXHRcdH0sXG5cdFx0YW5hbHl0aWNzOiB7XG5cdFx0XHRsYWJlbDogXCJBbmFseXRpY3NcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBgQW5hbHl0aWNzIGNvb2tpZXMgYWxsb3cgdXMgdG8gYW5hbHl6ZSB5b3VyIHZpc2l0cyBhbmRcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucyBvbiBvdXIgd2Vic2l0ZXMsIGFuZCBvZmZlciB5b3UgYSBtb3JlIHJlbGV2YW50XG4gICAgICAgICAgICAgICAgICAgIGV4cGVyaWVuY2UuYFxuXHRcdH1cbiAgfSxcblxuICBjb29raWU6IHtcbiAgICAvLyBOYW1lIG9mIHRoZSBjb29raWUgc3RvcmluZyB0aGUgY29uc2VudCBzdGF0ZVxuICAgIG5hbWU6IFwiY29va2llX2NvbnNlbnRcIixcblxuICAgIC8vIElmIG51bGwsIHdpbGwgdGFrZSBgbG9jYXRpb24uaG9zdG5hbWVgIGJ5IGRlZmF1bHRcbiAgICBkb21haW46IG51bGwsXG5cbiAgICAvLyBEdXJhdGlvbiBvZiB0aGUgY29uc2VudFxuICAgIGV4cGlyeURheXM6IDM2NSxcblxuICAgIC8vIElmIHRydWUsIHRoZSBjb29raWVzIHdpbGwgb25seSBiZSBhbGxvd2VkIG92ZXIgaHR0cHNcbiAgICBzZWN1cmU6IGZhbHNlLFxuXG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2ZyL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9TZXQtQ29va2llL1NhbWVTaXRlXG4gICAgc2FtZVNpdGU6IFwiTGF4XCIsXG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgXCIuL3N0eWxlcy9tYWluLnNjc3NcIlxuXG5pbXBvcnQgQ29va2llQ29uc2VudCBmcm9tIFwiLi9jb29raWVfY29uc2VudFwiXG5cbmV4cG9ydCBkZWZhdWx0IENvb2tpZUNvbnNlbnRcblxud2luZG93LkNvb2tpZUNvbnNlbnQgPSBDb29raWVDb25zZW50XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCJldmVudHNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPYnNlcnZhYmxlIHtcbiAgY29uc3RydWN0b3IoZW1pdHRlciA9IG51bGwpIHtcbiAgICB0aGlzLl9lbWl0dGVyID0gZW1pdHRlciB8fCBuZXcgRXZlbnRFbWl0dGVyKClcbiAgfVxuXG4gIG9uKCkgeyB0aGlzLl9lbWl0dGVyLm9uLmFwcGx5KHRoaXMuX2VtaXR0ZXIsIGFyZ3VtZW50cyl9XG4gIGVtaXQoKSB7IHRoaXMuX2VtaXR0ZXIuZW1pdC5hcHBseSh0aGlzLl9lbWl0dGVyLCBhcmd1bWVudHMpfVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==